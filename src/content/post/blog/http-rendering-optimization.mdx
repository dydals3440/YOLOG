---
title: 렌더링 최적화
date: 2025-09-24
updatedDate: 2025-09-24
tags: [렌더링, 최적화]
category: DEVELOPMENT
image: '/images/http-rendering-optimization/thumbnail.png'
---

# 렌더링 최적화

브라우저가 웹 페이지 하나를 렌더링하려면 이미지나 글꼴, 스타일시트 같은 추가 자원이 필요합니다. 이 자원들은 대부분 원격 서버에 있기 때문에 HTTP 요청을 통해서 불러와야 합니다.

그만큼 렌더링을 위한 비용을 치러야 합니다. 이번 포스팅에서는 브라우저가 웹 페이지를 렌더링할 때 발생하는 추가 HTTP 요청을 효율적으로 제어하는 다양한 방법을 배워보겠습니다.

이번 포스팅에서는 외부 리소스의 로드 시점을 조절하고 웹 성능을 최적화하는 기술을 정리하겠습니다.

원격지에 있는 자원을 내 컴퓨터에 다운로드해서 웹 문서로 보여주는 것이 브라우저의 역할입니다.

멀리 떨어진 자원을 가져오기 위한 프로토콜이 바로 우리가 지금 공부하고 있는 HTTP입니다. HTTP를 이용한 통신을 얼마나 잘 제어하느냐에 따라서 웹 페이지의 성능이 크게 좌우됩니다. 이번 장에서는 렌더링 과정에서의 HTTP를 이해하고 성능을 최적화하는 기법을 공부하겠습니다.

---

## 1. 렌더링 과정

사용자가 주소창에 URL을 입력하는 것부터 시작합니다. 브라우저는 해당 주소에 해당하는 IP 주소를 얻어야 서버를 찾을 수 있습니다. 이러한 역할을 하는 것을 도메인 네임 서버, 줄여서 DNS라고 부릅니다. 브라우저는 DNS로부터 IP 주소를 얻고 그제서야 서버와 연결할 수 있습니다.

서버와 연결된 브라우저는 필요한 문서를 요청하는데 이때부터 HTTP 통신을 시작합니다. 브라우저는 URL의 경로에 원하는 문서 파일을 요청합니다. 그리고 서버는 준비한 이 문서를 브라우저에게 응답해줄 것입니다.

웹 문서를 받은 브라우저는 이제부터 이 문서를 사람이 이해할 수 있는 형태로 화면에 그려야 합니다. 여기서부터 주요 렌더링 경로, `Critical Rendering Path(CRP)`라고 합니다.

CRP 렌더링 과정이 시작됩니다. 먼저 파싱 단계입니다.

HTML 문서를 렌더링하기 위한 구조로 파싱합니다.

문서를 렌더링하기 위한 구조가 `DOM`입니다. 파싱한 결과값인 토큰으로 이 `DOM`을 차근차근 만들어나갑니다. CSS 코드라면 `CSSOM`이라는 형태로 만듭니다. 그리고 이 두 개를 더해서 렌더 트리를 만듭니다.

브라우저가 렌더링하기 위한 구조가 완성된 셈입니다.

렌더 트리의 각 요소의 크기와 위치를 계산해서 화면에 배치하는 레이아웃 단계가 있고, 그리고 이 계산된 레이아웃을 기반으로 해서 화면에 실제 픽셀로 그려서 시각적인 결과를 출력합니다.

브라우저는 HTML 파일을 받으면 이러한 다섯 가지 단계를 거쳐 화면의 문서를 렌더링합니다.

```
Critical Rendering Path(CRP) 과정:

HTML 파싱 ──────→ DOM 생성
                     ↓
CSS 파싱 ───────→ CSSOM 생성
                     ↓
                렌더 트리 생성
                     ↓
                  레이아웃
                  (Reflow)
                     ↓
                  페인팅
                 (Repaint)
```

우리는 1번 과정인 파싱 단계를 자세히 살펴보겠습니다.

HTML은 마크업 코드로 구성된 문자라서 개발자가 이해할 수 있는 형식입니다.

브라우저가 이 문서를 올바르게 그리기 위해서는 브라우저 스스로 내용을 이해할 수 있어야 합니다. 그러한 형태로 변환하기 위한 분석 단계가 파싱입니다. 코드를 한 줄씩 읽어들이면서 브라우저에게 의미 있는 단위로 쪼개는 작업을 수행합니다. 파싱 중에 특정 코드를 만나면 브라우저는 파싱을 중단하고 이 특정 코드를 처리합니다.

예를 들면 아래와 같은 자바스크립트를 로딩하는 코드입니다.

```html
<script src="script.js"></script>
```

HTML 문서 어디에라도 이런 형태의 자바스크립트 로딩 코드가 있으면 브라우저는 파싱을 멈춥니다. 그리고 자바스크립트를 다운로드하기 위한 HTTP 요청을 만들기 시작합니다. 요청한 자바스크립트 파일을 서버가 응답하면 브라우저는 이 파일을 또 실행합니다.

자바스크립트를 다운로드하고 실행도 완료를 하면 브라우저는 이 코드 처리를 마친 것입니다. 그리고 이전에 중단했던 지점으로 돌아가서 다시 파싱을 재개합니다.

HTML 코드 내에서 이런 자바스크립트 로딩 코드가 있으면 렌더링에 영향을 줍니다. 브라우저는 파싱을 멈추고 HTTP 요청을 만들어야 되기 때문에 이 과정에서 시간이 더 소요됩니다. 이런 이유로 자바스크립트 파일이 많거나 혹은 로딩할 파일이 무거우면 페이지 로드 속도에 부정적인 영향을 줄 수 있습니다.

:::note
**핵심 정리**: 브라우저의 렌더링 과정은 파싱 → DOM/CSSOM → 렌더 트리 → 레이아웃 → 페인팅의 5단계를 거치며, `<script>` 태그를 만나면 파싱을 중단하고 자바스크립트를 다운로드/실행한 후 재개합니다.
:::

---

## 2. script 태그의 렌더링 영향도

간단하게 아래 코드를 설명하면 요청 핸들러가 있고 정적 파일을 처리하는 `static` 함수에게 핸들러 로직을 모두 위임했습니다. 그래서 public 폴더에 있는 정적 파일들을 제공하는 서버입니다.

```js
const http = require('http');
const path = require('path');
const static = require('../shared/serve-static');

const handler = (req, res) => {
  static(path.join(__dirname, 'public'))(req, res);
};

const server = http.createServer(handler);
const port = process.env.PORT || 3000;
server.listen(port, () => console.log(`server is running ::${port}`));
```

index.html 코드는 아래와 같습니다.

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <style>
      img {
        width: 50%;
      }
    </style>
  </head>
  <body>
  </body>
</html>
```

여기에 스크립트 코드를 하나 추가해볼 것입니다.

큰 파일을 로딩하고, 이어서 작은 파일을 로딩하는 간단한 스크립트를 추가해보겠습니다.

```html
<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />
  <style>
    img {
      width: 50%;
    }
  </style>
</head>

<body>
  <script src="script-big.js"></script>
  <script src="script-small.js"></script>
</body>

</html>
```

이 파일을 서버에서 제공해야 하니, 같은 이름으로 하나 만들어보겠습니다.

script-big.js는 그냥 간단하게 아래와 같이 콘솔에 출력하는 자바스크립트 파일이고

```js
console.log('script-big.js');
```

script-small.js도 마찬가지입니다.

```js
console.log('script-small.js');
```

두 자바스크립트는 이렇게 HTML에 로딩되면 각자의 파일 이름을 콘솔에 기록합니다. 두 자바스크립트는 이름처럼 응답 시간을 달리해야 합니다. 그래야 무거운 파일인지, 가벼운 파일인지 흉내낼 수 있기 때문입니다. 정적 파일을 처리하는 이 shared의 serve-static.js 파일로 가보겠습니다.

```js
const fs = require('fs');
const path = require('path');

const serveStatic = (root) => {
  return (req, res) => {
    const filepath = path.join(root, req.url === '/' ? '/index.html' : req.url);

    fs.readFile(filepath, (err, data) => {
      if (err) {
        if (err.code === 'ENOENT') {
          res.statusCode = 404;
          res.write('Not Found\n');
          res.end();
          return;
        }

        res.statusCode = 500;
        res.write('Internal Server Error\n');
        res.end();
        return;
      }

      const ext = path.extname(filepath).toLowerCase();
      let contentType = 'text/html';
      switch (ext) {
        case '.html':
          contentType = 'text/html';
          break;
        case '.js':
          contentType = 'text/javascript';
          break;
        case '.css':
          contentType = 'text/css';
          break;
        case '.png':
          contentType = 'image/png';
          break;
        case '.json':
          contentType = 'application/json';
          break;
        case '.otf':
          contentType = 'font/otf';
          break;
        default:
          contentType = 'application/octet-stream';
      }
      res.setHeader('Content-Type', contentType);

      // 인터페이스 추가
      if (res.delayMs) {
        setTimeout(() => {
          res.write(data);
          res.end();
        }, res.delayMs);

        return;
      }

      res.write(data);
      res.end();
    });
  };
};

module.exports = serveStatic;
```

이제 루트로 들어오는 public 폴더에 있는 파일들을 읽어서 응답해주는 핸들러입니다. 핸들러 맨 아래쪽 로직을 보면 본문을 싣는 `write` 함수 위쪽에 인터페이스를 하나 추가했습니다. `delayMs`에서 응답 지연 시간을 response 객체의 이 속성으로 받는 것입니다.

`res.delayMs`만큼 지연하고 아래 있는 것처럼 본문을 싣고 응답을 종료하는 로직입니다. 그리고 이 분기문에서 로직을 빠져나오겠습니다. 그래서 이 앞단에서 `delayMs`의 시간을 밀리초 단위로 지정을 하면 그만큼 이 서버는 응답을 지연해서 보낼 것입니다.

인터페이스를 추가했으니 server.js로 돌아가보겠습니다.

이 정적 파일을 처리하기 전에 요청한 파일 이름에 따라서, 지연하는 `delayMs`를 설정하는 코드를 작성해보겠습니다.

```js
const http = require('http');
const path = require('path');
const static = require('../shared/serve-static');

const handler = (req, res) => {
  // filename 가져오기
  const filename = path.basename(req.url);

  if (filename === 'script-big.js') {
    // 3초 후 응답
    res.delayMs = 3_000;
  }

  if (filename === 'script-small.js') {
    // 1초 후 응답
    res.delayMs = 1_000;
  }

  static(path.join(__dirname, 'public'))(req, res);
};

const server = http.createServer(handler);
const port = process.env.PORT || 3000;
server.listen(port, () => console.log(`server is running ::${port}`));
```

이렇게 하면 브라우저에서 빅과 스몰을 호출할 때 빅은 3초 걸리고 스몰은 1초가 걸릴 것입니다. 서버를 실행시켜보겠습니다.

Firefox 브라우저 같은 경우 about:config 가서 설정을 일부 변경해야 합니다.

`network.http.max-persistent-connections-per-server`에서 서버 연결할 수 있는 최대 개수를 6개에서 0으로 꺼볼 것입니다.

![network.http.max-persistent-connections-per-server을 6 -> 0으로 변경](/images/http-rendering-optimization/1.png)

그리고 로컬호스트 3000번에 접속을 해보겠습니다.

![로컬호스트 3000번에 접속](/images/http-rendering-optimization/2.png)

script-big.js가 로딩되고 이어서 script-small.js가 로딩됐습니다.

브라우저는 http://localhost:3000번으로 요청을 하면 서버는 HTML을 브라우저로 응답합니다.

브라우저가 파일의 내용을 읽으면서 한 줄씩 파싱하기 시작합니다. 그러다가 이 스크립트 로딩 태그를 만나게 되면 파싱을 멈춥니다.

왜냐하면 `src`에 있는 script-big.js 파일을 가져오기 위해서 네트워크 요청을 보내기 때문입니다. 서버는 3초 정도 후에 이 파일을 브라우저까지 전달해줍니다. 그러면 브라우저는 이 파일을 실행해서 script-big.js라는 콘솔 로그를 기록합니다. 이렇게 해서 브라우저는 스크립트 하나를 처리했습니다.

그리고 나서 파싱을 재개하고 다시 스크립트 로딩 태그를 만납니다. 위에서 했던 것처럼 똑같이 파싱을 멈추고 script-small.js를 가져오기 위한 네트워크 요청을 만듭니다.

![script-big.js, script-small.js를 가져오기 위한 네트워크 요청을 만든다](/images/http-rendering-optimization/3.png)

이렇게 스크립트 로딩을 완료하고 브라우저는 멈췄던 파싱을 다시 재개합니다. 그래서 한 줄 한 줄씩 읽고 마침내 `DOM` 객체를 완성합니다. 브라우저가 렌더링하기 위해서 문서를 파싱하는데 스크립트 태그를 처리하기 위해서 대략 4초 정도의 시간을 소요했습니다.

script-big.js와 script-small.js를 가져오고 그리고 나서 둘 다 실행하는데 대략 4초 정도의 시간이 소요됐습니다.

조금 더 정확하게 시간을 측정해보겠습니다. 브라우저의 Performance API를 사용하면 밀리초 단위로 시간을 잴 수 있습니다.

먼저 스크립트를 로딩하기 직전에 `window`에서 제공해주는 Performance API를 사용해보겠습니다.

아래와 같이 `performance.mark`를 통해 측정 시작 시점을 표기하고

```html
<body>
  <!-- 측정 시각을 표기할 수 있음 -->
  <script>
    performance.mark('script-big-start');
  </script>
  <script src="script-big.js"></script>
  <script>
    performance.mark('script-small-start');
  </script>
  <script src="script-small.js"></script>
</body>
```

아래에 `performance.mark`를 통해 측정 종료 시점을 표기한 후, `performance.measure`를 통해 실제 시간을 측정합니다.

```js
console.log('script-big.js');

// 측정 종료 시각 표기
performance.mark('script-big-end');
performance.measure(
  'script-big execution time',
  'script-big-start',
  'script-big-end'
);
```

```js
console.log('script-small.js');

// 측정 종료 시각 표기
performance.mark('script-small-end');
performance.measure(
  'script-small execution time',
  'script-small-start',
  'script-small-end'
);
```

각각 표기해주고, 그 후에 브라우저는 필요한 모든 리소스를 로딩하면 로드 이벤트를 발행합니다. 이 시점에 웹 문서와 모든 자바스크립트가 로딩을 마친 것입니다. 이 이벤트를 구독해서 결과를 표시하는 코드도 추가하겠습니다.

```html
  <script>
    // DOM이 완성되면 발생하는 이벤트
    window.addEventListener('DOMContentLoaded', () => {
      console.log('DOMContentLoaded')
    })

    // 모든 리소스 로딩이 완료되면 발생하는 이벤트
    window.addEventListener('load', () => {
      console.log('load')
      // 측정한 성능 데이터 가져오기
      const entries = performance.getEntriesByType('measure')
      entries.forEach(entry => {
        const result = `${entry.name} : ${entry.startTime}, ${entry.duration} ms`
        console.log(result)
      })
    })
  </script>
```

![performance.mark를 통해 측정 시각을 표기할 수 있음](/images/http-rendering-optimization/4.png)

브라우저를 확인하면, script-big과 script-small이 다 실행됐고, 그런 다음에 `DOM`이 생성됐습니다. 그리고 모든 자바스크립트 리소스가 로드된 다음에 측정 결과를 아래와 같이 표시했습니다. 스크립트 빅은 45ms에 시작해서 3초 정도 걸렸고, script small은 3초 정도에 시작해서 1초 정도 소요됐습니다.

그래서 렌더링에 총 4초 정도가 소요됨을 확인할 수 있습니다. 이 실험 결과를 통해 알 수 있듯이 스크립트 태그가 많을수록 웹 페이지를 파싱하는데 시간은 오래 걸릴 것입니다. 이 스크립트가 없었다면 1초 안에 렌더링을 마쳤을 것입니다. 하지만 스크립트 로딩을 위해 HTTP 요청을 만들면서 그만큼 렌더링 시간에 부정적인 영향을 주게 됩니다.

---

## 3. Async 스크립트

렌더링에 영향을 주지 않으려면 우선 브라우저가 멈추지 말고 계속 파싱을 해야 합니다. 파싱을 멈추는 이유는 HTML 문서에 사용할 자바스크립트를 다운로드하기 위해서 HTTP 요청을 만들고 응답을 기다리기 때문입니다.

이 파싱과 HTTP 요청, 이 두 작업을 하나의 메인 스레드가 처리하기 때문입니다. 브라우저는 애플리케이션을 동작시키는 메인 스레드뿐만 아니라 백그라운드 잡을 실행하는 다른 스레드들도 여러 개 있습니다.

그중에 I/O 스레드는 네트워크 요청이나 파일의 입출력, 그리고 다른 외부 자원과의 통신을 담당하는 스레드입니다.

HTTP 요청과 같은 네트워크 작업을 이 스레드가 처리할 수 있습니다. 그래서 브라우저는 파싱 중에 스크립트의 특별한 속성을 발견하면 메인 스레드가 파싱하지 않습니다.

바로 이 script 태그의 `async` 속성인데요, 이 속성을 브라우저가 만나면 I/O 스레드에게 스크립트 다운로드를 부탁하고, 메인 스레드는 계속 파싱을 이어서 합니다. 다운로드를 함과 동시에 파싱도 멈추지 않고 계속 진행할 수 있어서 처리 시간을 단축하는 효과가 있습니다. `async` 속성을 스크립트에 추가해보겠습니다.

```html
<body>
  <script>performance.mark("script-big-start")</script>
  <script src="script-big.js" async></script>
  <script>performance.mark("script-small-start")</script>
  <script src="script-small.js" async></script>
</body>
```

브라우저는 script-big을 다운로드합니다 동시에 그 다음 문장을 파싱할 것입니다. 그리고 script-small도 다운로드할 것입니다.

그러면 이제 다시 브라우저 설정을 복구하고 확인해보겠습니다.

![위에서 6으로 바꾼 것을 다시 0으로 변경](/images/http-rendering-optimization/5.png)

![위와 다르게 async 속성 시 스크립트 파일을 동시에 다운로드 함.](/images/http-rendering-optimization/6.png)

위의 이미지를 보면 스크립트 파일을 동시에 다운로드함을 확인할 수 있습니다. 29ms에 동시에 다운로드가 시작되었습니다.

메인 스레드가 `DOM`을 먼저 만들고, 좀 더 가벼운 script-small.js가 먼저 다운로드가 완료되었습니다. 그러면 메인 스레드는 이걸 처리합니다. 스크립트를 실행해서 console.log를 출력한 것입니다. 이게 약 1초 정도에 찍혔습니다.

이어서 script-big도 다운로드가 완료되면 메인 스레드가 이것도 실행합니다.

![기존 1초 + 3초 = 4초 이지만, async 속성시 3초 소요](/images/http-rendering-optimization/7.png)

console.log를 찍고 그 시간이 3초 정도 걸렸습니다. 총 시간은 이전 4초에서 3초 정도로 줄었습니다. 네트워크 탭에서도 script-big과 script-small이 동시에 다운로드됨을 확인할 수 있습니다.

`async`는 자원을 동시에 다운로드하고 다운로드를 완료한 순서대로 실행합니다. 코드에서 script-big.js를 먼저 로드했지만, 뒤에 등장한 script-small이 big보다 더 빨리 다운로드되기 때문에 먼저 실행된 것입니다.

이런 `async` 스크립트는 `DOM`에 무관한 스크립트, 그리고 서로 영향을 주지 않는 스크립트에 적합합니다. 왜냐하면 코드의 명시한 순서가 아니라 다운로드 된 순서대로 실행되기 때문입니다.

그래서 애플리케이션에 무관한 광고 스크립트나 분석 트래커에 `async`로 스크립트를 로딩하면 좋습니다.

```
async vs defer 실행 순서 비교:

일반 스크립트:
HTML 파싱 → [중단] → 스크립트 다운로드 → 스크립트 실행 → [파싱 재개]

async 스크립트:
HTML 파싱 ────────────────────────→ DOM 생성
     ↓ (병렬)
스크립트 다운로드 → [다운로드 완료 시 즉시 실행]

defer 스크립트:
HTML 파싱 ────────────────────────→ DOM 생성 → [순서대로 실행]
     ↓ (병렬)
스크립트 다운로드 ─────────────────┘
```

:::note
**핵심 정리**: `async` 속성은 스크립트를 병렬로 다운로드하고 완료된 순서대로 실행합니다. DOM과 무관하고 서로 독립적인 스크립트(광고, 분석 도구 등)에 적합합니다.
:::

---

## 4. Defer 스크립트

`async`는 파싱과 동시에 자바스크립트를 병렬로 다운로드합니다. 그래서 처리속도가 빠르기도 하지만 자바스크립트 실행 순서까지는 보장하지 않습니다. 이전처럼 `async`가 없으면 메인 스레드에서 순서대로 다운로드하고 실행하기 때문에 이게 느리긴 하지만 개발자가 정의한 순서대로 코드를 실행합니다.

자바스크립트가 서로 의존적일 경우에는 `async`가 적합하지 않을 수 있습니다. script-big에 아래와 같은 게 있다고 해보겠습니다. `foo`라는 함수를 `window` 객체에 정의하겠습니다. 누군가 이거를 쓰도록 의도한 겁니다.

```js
console.log('script-big.js');

// 전역 객체에 함수 등록 (다른 스크립트에서 사용 예정)
window.foo = () => console.log('foo is executed');

performance.mark('script-big-end');
performance.measure(
  'script-big execution time',
  'script-big-start',
  'script-big-end'
);
```

그리고, 이 script-big 다음에 실행되는 script-small에서는 저 `foo` 함수를 호출하도록 해보는 것입니다.

```js
console.log('script-small.js');

// 전역 객체에 등록된 함수 호출
foo();

performance.mark('script-small-end');
performance.measure(
  'script-small execution time',
  'script-small-start',
  'script-small-end'
);
```

script-small은 `foo` 함수가 전역 객체에 등록되었다는 전제하에 코드를 작성했습니다. 실행해보겠습니다.

![async 시 스크립트 크기가 작은 것을 먼저 로드하기 때문에, 에러가 발생](/images/http-rendering-optimization/8.png)

코드 상으로는 우리가 big을 small보다 먼저 로딩하도록 했습니다. 하지만 `async` 스크립트로 로딩했기 때문에 두 파일을 동시에 다운로드하기 시작해서 다운로드를 완료한 것 먼저 실행됩니다. 그래서 3초 걸리는 big에 비해서 1초 걸리는 small이 먼저 실행된 것입니다. 브라우저는 이 스크립트를 실행할 때 아직 전역 객체의 `foo` 함수가 없어서 이렇게 레퍼런스 오류를 발생한 것입니다.

브라우저가 다운로드를 동시에 하더라도 코드에 정의한 순서대로 실행해야 개발자가 의도한 대로 애플리케이션이 동작할 것입니다.

이렇게 다운로드 시점을 앞당기면서 실행 순서까지 보장하는 것이 `defer` 속성입니다. 파싱이랑 동시에 파일을 다운로드하기 때문에 처리 속도를 높이지만 실행은 하지 않고 `DOM`이 생성되는 시간까지 기다리는 것입니다.

이번에는 `defer`를 추가해보겠습니다.

```html
<body>
  <script>performance.mark("script-big-start")</script>
  <script src="script-big.js" defer></script>
  <script>performance.mark("script-small-start")</script>
  <script src="script-small.js" defer></script>
</body>
```

다시 브라우저를 실행해보겠습니다.

![defer 시 스크립트 파일을 동시에 다운로드 함. async와 다르게 코드 순서대로 실행](/images/http-rendering-optimization/9.png)

브라우저는 big과 small을 동시에 다운로드 시작합니다. 약 40ms가 걸립니다. 그리고 `DOM`이 만들어지기 직전에 big-script를 먼저 실행하고, small-script를 실행합니다. 코드의 정의된 순서대로 스크립트를 실행합니다. 그리고 처리를 완료합니다. 그게 한 3초 정도 걸리는 것입니다.

네트워크를 봐도 동시에 big과 small 스크립트를 다운로드함을 확인할 수 있습니다.

`async`와 다르게 `defer` 스크립트는 스크립트를 모두 동시에 다운로드하지만, 빨리 다운로드됐다고 실행하지 않습니다. 바로 이 코드에 등장하는 순서대로 스크립트를 실행합니다.

![동일하게 총 3초 정도 걸리며 순서대로 실행됨을 확인할 수 있음.](/images/http-rendering-optimization/10.png)

이처럼 `defer`는 서로 영향 있는 스크립트에 적합합니다.

애플리케이션을 만들 때 webpack 같은 번들러 도구를 많이 사용하는데, 필요에 따라 chunk라고 부르는 작은 자바스크립트 파일로 쪼개서 빌드합니다. 여러 개 chunk 파일은 HTML에 모두 로딩이 돼야 하는데, 의존성에 따라서 순서대로 로딩되어야 합니다.

그래서 [webpack이 HTML에 chunk를 추가](https://webpack.js.org/guides/code-splitting/#prefetchingpreloading-modules)할 때 이런 `defer` 속성을 추가합니다. 왜냐하면 의존성에 따라서 순서에 맞춰서 실행해야 하기 때문입니다.

:::note
**핵심 정리**: `defer` 속성은 스크립트를 병렬로 다운로드하되, DOM 생성 후 코드에 정의된 순서대로 실행합니다. 서로 의존적인 스크립트나 webpack chunk 파일에 적합합니다.
:::

---

## 5. Preload 링크

브라우저가 HTML 문서를 렌더링하다가, HTTP 요청을 만드는 자원은 이렇게 자바스크립트만 있는 것이 아닙니다. 글꼴, 스타일시트, 이미지 같은 문서에 필요한 모든 자원은 원격지인 서버에 있기 때문에 다운로드하기 위해서 HTTP 요청을 똑같이 만듭니다.

자바스크립트 로딩 시점을 조절해서 렌더링 시간을 줄이는 것처럼 웹 문서에 필요한 모든 문서도 다운로드 시점을 앞당길 수 있습니다. Link 태그의 `preload` 속성은 자바스크립트뿐만이 아니라 웹 문서에 필요한 자원을 렌더링과 상관없이 미리 다운로드할 수 있는 속성입니다.

용량이 큰 이미지를 다운로드하는 상황으로 속성을 더 살펴보겠습니다.

버튼을 하나 추가해보겠습니다.

```html
<body>
  <button id="imageAddButton">이미지 추가</button>
  <script>
    // 버튼 클릭 시 이미지를 동적으로 추가
    document.querySelector('#imageAddButton').addEventListener('click', () => {
      // img 엘리먼트 생성
      const img = document.createElement('img')
      // 이미지 경로 설정
      img.src = '/goguma.jpg'
      // body에 이미지 추가 (이 시점에 네트워크 요청 발생)
      document.body.appendChild(img)
    })
  </script>
</body>
```

그리고 server.js에서 goguma.jpg일 때 지연하도록 추가해보겠습니다.

```js
const handler = (req, res) => {
  // filename 가져오기
  const filename = path.basename(req.url);

  if (filename === 'goguma.jpg') {
    // 1초 후 응답
    res.delayMs = 1_000;
  }

  static(path.join(__dirname, 'public'))(req, res);
};
```

그리고 서버를 실행시켜보겠습니다. 버튼이 생길 것이고 그걸 이제 클릭하면 1초 정도 이후에 고구마 이미지가 보일 것입니다.

![버튼 클릭 후 1초 후에 고구마 이미지가 보일 것이다.](/images/http-rendering-optimization/11.png)

이러한 구조에서는 다운로드할 이미지가 크다면 그만큼 렌더링은 늦게 완료될 것입니다.

사용자는 버튼을 클릭하고 한참 기다린 뒤에 이미지를 볼 수 있을지도 모릅니다. script 태그에 `async`나 `defer` 속성을 주어서 주요 렌더링 경로에 영향 없이 자바스크립트 파일을 빠르게 다운로드했는데요.

이런 이미지도 브라우저에 미리 다운로드해두면 좋을 것 같습니다. 사용자가 클릭한 것처럼 필요할 때 이미지 파일을 즉시 사용할 수 있기 때문입니다.

이번엔 header 쪽으로 가서 link `rel` 속성을 통해 `preload`를 주면 됩니다. preload할 리소스 주소를 넘기고 어떤 것인지 명시해주면 됩니다.

```html
<head>
  <link rel="preload" href="/goguma.jpg" as="image" />
</head>
```

브라우저는 HTML을 위에서부터 파싱하다가 위의 마크업을 만나면, 파싱을 멈추지 않으면서 자원을 동시에 다운로드합니다.

`async`와 `defer`와 같은 방식입니다.

![미리 이미지를 preload 함](/images/http-rendering-optimization/12.gif)

위의 영상을 보면 버튼을 클릭하지 않았음에도, 미리 고구마 이미지를 다운로드받아오는 것을 확인할 수 있습니다.

그래서 이미지 추가를 누르면 미리 다운로드한 파일을 바로 보여줄 수 있는 것입니다.

`preload`는 미리 다운로드해야 할 어떤 자원이든 적용할 수 있습니다. 지금처럼 이미지도 되고, 비디오, 스타일시트, 폰트, 자바스크립트 등에도 이렇게 사용할 수 있습니다.

:::note
**핵심 정리**: `preload`는 현재 페이지에서 곧 사용될 중요한 리소스를 미리 다운로드하여 실제 사용 시점의 로딩 시간을 제거합니다.
:::

---

## 6. Prefetch 링크

`preload`를 이용해서 자원 사용하는 체감 시간을 줄였습니다. 사용자는 HTTP 요청을 만들고 다운로드되는 것을 기다리고 있다는 걸 체감조차 못합니다.

이렇게 웹 페이지 성능을 높일 수 있는 기법입니다. 웹 문서에는 하이퍼링크가 있어서 사용자가 이걸 클릭해서 다음 페이지로 이동할 수 있습니다. 현재 문서를 표시하는 중에 사용자가 이동할 것이라고 예측하는 다음 페이지의 자원을 미리 다운로드해도 `preload`와 같은 원리로 웹 페이지의 성능을 높일 수 있을 것입니다.

다음 문서에 사용할 자원을 미리 가져오는 것을 `prefetch`라고 합니다. 어떻게 다음 페이지와 그 페이지에서 사용할 수 있는 자원을 알 수 있을까요?

이건 전적으로 개발자가 결정해야 될 문제입니다. 현재 문서에서 사용되는 링크의 문서나 그 문서에서 사용하는 자바스크립트를 미리 불러오는 방식입니다. 이렇게 미리 불러오면 다음 웹 페이지로 이동했을 때 미리 다운로드한 자원을 사용하기 때문에 더 빠르게 렌더링할 수 있습니다. HTML 문서에 하이퍼링크를 하나 추가해보겠습니다.

```html
<body>
  <a href="goguma.html">Goguma들이 모인 Page</a>
</body>
```

이렇게 바로 갈 수 있는 하이퍼링크를 바디 태그에 추가하겠습니다.

그리고 goguma.html을 하나 만들어보겠습니다.

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Goguma들이 모인 페이지</title>
</head>

<body>
    <h1>Goguma들이 모인 페이지</h1>
</body>

</html>
```

이 페이지에 지연 효과를 주기 위해서 위와 동일하게 서버 핸들러에 딜레이도 추가해주겠습니다.

브라우저별 요구 사항이 다르니 헤더를 추가해주겠습니다.

```js
if (filename === 'goguma.html') {
  // 3초 후 응답
  res.delayMs = 3_000;
  // prefetch를 위한 캐싱 헤더 추가
  // Firefox는 prefetch하기 위해 캐싱 헤더가 필요함
  res.setHeader('Cache-Control', 'max-age=3600');
}
```

서버를 다시 실행해보겠습니다.

![Goguma들이 모인 Page 버튼이 보임](/images/http-rendering-optimization/13.png)

그러면 이 Goguma들이 모인 Page가 있을 것입니다. 이걸 누르고 클릭하면 3초 정도 소요되고 고구마들이 모인 페이지가 보일 것입니다.

![클릭 후 3초 후에 Goguma들이 모인 페이지가 보임](/images/http-rendering-optimization/14.png)

이동할 페이지의 크기가 크거나 HTML 응답에 시간이 걸리면 이렇게 렌더링은 늦게 완료됩니다. 사용자는 링크를 클릭하고 한참 기다린 뒤에 다음 페이지를 보게 될 것입니다.

우리가 `preload`할 때 링크 태그를 이용해서 미리 자원을 다운로드했는데요, 다음 페이지의 자원도 비슷하게 처리할 수 있습니다.

```html
<head>
  <link rel="prefetch" href="goguma.html" as="document" />
</head>
```

브라우저는 현재 문서 렌더링에 필요한 모든 작업을 처리하고 나서 남는 시간 즉 유휴 시간에 `prefetch`로 설정한 파일을 다운로드한다고 합니다.

![이제 다음 페이지의 자원을 미리 다운로드 함](/images/http-rendering-optimization/15.gif)

실제로 실행시키면 바로 이제 3초의 지연 없이 들어가볼 수 있는 것을 확인할 수 있습니다.

아직 클릭하지 않았지만, 우리가 `prefetch`로 설정했기 때문에 브라우저가 유휴 시간에 미리 다운로드해놓은 것입니다.

이 Link Prefetch는 모든 브라우저에서 동작하지 않습니다.

![prefetch는 can i use를 보면 브라우저별 제한이 있음](/images/http-rendering-optimization/16.png)

Firefox는 위에서 본 것처럼 캐시 헤더가 있어야 동작합니다. Chrome은 이런 것과 무관하게 잘 동작했습니다. 애플리케이션의 브라우저 지원 범위를 고려하면서 활용해야 합니다. [Can I Use에서 prefetch 브라우저 호환성](https://caniuse.com/link-rel-prefetch)을 확인할 수 있습니다.

`prefetch`는 다음 문서의 렌더링 성능을 높일 때 사용합니다. [Next.js](https://nextjs.org/docs/api-reference/next/link)나 [Gatsby](https://www.gatsbyjs.com/docs/how-to/performance/link-prefetching/), webpack 같은 데서도 적극적으로 사용을 합니다.

Gatsby.js는 자체 빌드 설정으로 prefetch 기능을 사용합니다. webpack도 prefetch를 사용합니다. 모듈을 불러올 때 주석으로 아래와 같이 `webpackPrefetch: true`라고 쓰면

```js
import(/* webpackPrefetch: true */ './path/to/LoginModal.js');
```

코드를 빌드할 때 link prefetch를 코드에 넣어주는 기능도 있습니다. Next.js 프레임워크는 자체 제작한 Link 컴포넌트가 있는데 이걸 사용하면 prefetch 기능을 제공한다고 합니다.

:::note
**핵심 정리**: `prefetch`는 다음 페이지에서 사용될 리소스를 유휴 시간에 미리 다운로드합니다. 브라우저 호환성을 확인하고, 다음 페이지 예측이 가능한 경우에 사용하면 효과적입니다.
:::

---

## 7. 이미지 지연 로딩

이미지 태그는 문서를 로딩하는 시간을 지연시킬 수 있습니다. 한 문서에 많은 이미지가 있으면 그 개수만큼 브라우저가 HTTP 요청을 만들고 서버에 응답을 기다리기 때문입니다.

아까는 클릭했을 때 이미지가 왔는데 이번에는 바로 이미지를 로딩하게 해보겠습니다.

index.html을 와서 고구마 사진 여러 개를 한번 로드해보겠습니다.

```html
<body>
  <img src="/goguma.jpg" alt="고구마1 이미지" />
  <img src="/goguma2.jpg" alt="고구마2 이미지" />
</body>
```

그리고, 서버 핸들러에 지연되게 로딩하게 늘리겠습니다.

```js
const handler = () => {
  if (filename === 'goguma.jpg') {
    // 1초 후 응답
    res.delayMs = 1_000;
  }

  if (filename === 'goguma2.jpg') {
    // 1초 후 응답
    res.delayMs = 1_000;
  }
};
```

그리고, 이미지 두 개를 지연 로드를 했지만 두 번째 고구마 이미지는 뷰포트 밖으로 밀어버려보겠습니다.

```html
<body>
  <img src="/goguma.jpg" alt="고구마1 이미지" />
  <div style="height: 1000vh; border: solid 1px black">빈 박스</div>
  <img src="/goguma2.jpg" alt="고구마2 이미지" />
</body>
```

그러면 이 두 번째 고구마 이미지는 뷰포트 밖으로 밀려나서 사용자에게 보이지 않을 것입니다.

![2번째 고구마 이미지는 뷰포트 밖으로 밀려나서 보이지 않음, 굳이 이걸 로딩할 필요가 있을까?](/images/http-rendering-optimization/17.png)

스크롤을 내리면 어딘가에 두 번째 고구마 이미지가 있을 것입니다.

네트워크 탭을 보면 고구마 두 개의 이미지 모두 네트워크 요청이 만들어졌습니다.

사용자 입장에서는 첫 번째 고구마 이미지만 있어도 충분합니다. 왜냐하면 두 번째 고구마 이미지는 뷰포트 아래에 있어서 사용자가 볼 확률이 매우 적기 때문입니다.

사용자가 스크롤하지 않고, 다른 페이지로 이동하면 정말 필요 없는 자원이 됩니다.

뷰포트 안에 있는 이미지만 다운로드하면 렌더링 성능을 높일 수 있을 것입니다.

뷰포트 밖에 있는 이미지는 사용자가 스크롤해서 뷰포트 안에 들어올 때 그때 로드해도 충분합니다. 코드에 가서 이미지를 지연 로드하는 설정을 추가해보겠습니다.

```html
  <img src="/goguma.jpg" alt="고구마1 이미지" loading="eager" />
  <div style="height: 1000vh; border: solid 1px black">빈 박스</div>
  <img src="/goguma2.jpg" alt="고구마2 이미지" loading="eager" />
```

이미지 태그에 `loading` 속성이 있습니다. 이것을 사용하면 지연 로드를 사용할 수 있습니다.

기본값은 `loading`이 `eager`여서 항상 모든 자원들을 다운로드하게 되어 있습니다.

```html
  <img src="/goguma.jpg" alt="고구마1 이미지" loading="lazy" />
  <div style="height: 1000vh; border: solid 1px black">빈 박스</div>
  <img src="/goguma2.jpg" alt="고구마2 이미지" loading="lazy" />
```

이것을 모두 `lazy`로 변경하면 이미지 태그가 뷰포트 안에 들어올 때만 HTTP 요청을 만들게 됩니다. 이렇게 하고 다시 확인해보겠습니다.

![뷰포트 안에 들어올 때 HTTP 요청을 만듬](/images/http-rendering-optimization/18.gif)

1번 고구마 사진을 먼저 로딩하고, 2번 고구마 사진은 이 엘리먼트가 뷰포트에 들어오기 직전에 네트워크 요청을 만들어냅니다.

이미지가 많은 사진첩이나 블로그에서 이런 `lazy` 로드를 사용하면 좋습니다. 특히 스크롤이 많은 모바일 환경에서는 성능 최적화로 사용하면 좀 더 극적인 효과를 볼 수 있을 것입니다.

:::note
**핵심 정리**: 이미지 태그의 `loading="lazy"` 속성을 사용하면 뷰포트에 들어올 때만 이미지를 로드하여 초기 렌더링 성능을 크게 개선할 수 있습니다.
:::

---

## 마무리

이번 포스팅에서는 브라우저의 렌더링 과정과 최적화 기법들을 알아보았습니다.

- **Critical Rendering Path**: 파싱 → DOM/CSSOM → 렌더 트리 → 레이아웃 → 페인팅
- **스크립트 최적화**: `async`와 `defer` 속성으로 파싱 차단 방지
- **리소스 프리로딩**: `preload`와 `prefetch`로 중요 리소스 미리 다운로드
- **이미지 지연 로딩**: `loading="lazy"`로 뷰포트 외부 이미지 지연 로드

이러한 기법들을 적절히 활용하면 웹 페이지의 로딩 성능을 크게 개선할 수 있습니다. 특히 모바일 환경이나 네트워크가 느린 환경에서 더욱 효과적입니다.

> **참고 자료**:
> - [MDN - 리소스 우선순위 지정](https://developer.mozilla.org/ko/docs/Web/Performance/Resource_prioritization)
> - [Google Web.dev - 리소스 우선순위 지정](https://web.dev/articles/prioritize-resources)
> - [webpack Prefetch 공식 문서](https://webpack.js.org/guides/code-splitting/#prefetchingpreloading-modules)